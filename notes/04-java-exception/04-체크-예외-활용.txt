==== 체크 예외 활용 ====
체크 예외와 언체크(런타임) 예외는 각각 언제 사용해야 하나?

* 기본 원칙은 다음 2가지이다.
- 기본적으로 언체크(런타임) 예외를 사용하자.
- 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자.
    - 반드시 잡아서 처리해야 하는 문제일 때만 체크 예외를 사용해야 한다. 아래는 예시이다.
        - 계좌 이체 실패 예외
        - 결제 시 포인트 부족 예외
        - 로그인 ID, PW 불일치 예외
    - 물론 위와 같은 경우라 할지라도 100% 체크 예외로 해야하는 것은 아니다. 오히려 런타임으로 두는 편이 나을 때도 있다. (대신 문서로 잘 남겨야 한다.)
    - 너무나 중요하고 핸들링을 빼 먹으면 심각한 문제가 생기는 예외를 체크 예외로 하면 된다. 그래야 컴파일러가 경고를 줄 수 있다.

* 체크 예외 문제점 - 그림
체크 예외는 명시적으로 예외를 처리하도록 도와준다.
체크 예외가 런타임 예외보다 더 안전해 보이는데, 왜 체크 예외를 기본으로 사용하는 것이 문제가 될까?

- 예외 전파 그림
[예외 공통 처리 (ControllerAdvice 등)] <--- 전파 -- [Controller] <-- 전파 -- [Service] <-- 전파 -- [Repository - SQLException]
                                                                                <-- 전파 -- [NetworkClient - ConnectException]
    - 리포지토리는 SQLException 체크 예외를 던진다.
    - NetworkClient는 외부 네트워크에 접속해서 어떤 기능을 처리하는 객체이다. ConnectException 체크 예외를 던진다.
    - 서비스는 리포지토리와 NetworkClient 둘 다 호출한다.
        - 따라서 두 곳에서 발생시킬 수 있는 SQLException, ConnectException 둘 다 처리해야 한다.
        - 하지만 서비스는 이 둘을 처리할 방법을 모른다. 연결 실패, 데이터베이스에서 발생한 문제는 대부분 애플리케이션에서 처리할 수 없는 성격의 예외이다.
    - 서비스는 둘을 처리할 수 없으므로 밖으로 던진다.
        - 체크 예외이기 때문에 다음과 같이 선언해야 한다.
        - method() throws SQLException, ConnectException
    - 컨트롤러도 둘을 처리할 방법을 모르므로 밖으로 던진다.
        - method() throws SQLException, ConnectException
    - 웹 애플리케이션이라면 서블릿의 오류 페이지나 스프링 MVC가 제공하는 ControllerAdvice에서 이런 예외를 공통으로 처리한다.
        - 이런 문제들은 보통 사용자에게 자세히 설명되지 않는다. 다만 "서비스에 문제가 있습니다" 정도로 설명된다.
          "데이터베이스에 어떤 오류가 발생했어요" 라고 설명할 수도 없고 설명해서도 안된다.
          왜냐하면 일반 사용자는 이해할 수도 없을 뿐더러, 보안에도 문제가 될 수 있기 때문이다.
        - API라면 보통 HTTP 상태코드 500(내부 서버 오류)으로 응답을 내려준다.
        - 이렇게 해결이 불가능한 공통 예외는 별도의 오류 로그를 남기고, 개발자가 오류를 빨리 인지할 수 있도록 메일, 알림(문자, 슬랙)등이 문제를 알려야 한다.
          예를들어 SQLException이 잘못된 SQL을 작성해서 발행했다면 개발자가 해당 SQL을 수정해서 배포하기 전까지는 사용자는 동일한 문제를 겪게 된다.

    --> 즉, 굳이 알 필요가 없는 예외를 서비스, 컨트롤러에 뭍히는(명시적 throws 선언문) 결과를 낳았다.

* 체크 예외 문제점 - 코드
CheckedAppTest.java
- 서비스, 컨트롤러 모두 SQLException, ConnectException 을 처리하지 못한다.
  또한 둘 모두 체크 예외이기 때문에 throws 선언이 필요했다.

* 2가지 문제
지금까지 설명한 예시와 코드를 보면 크게 2가지 문제를 발견할 수 있다.
- 복구 불가능한 예외
- 의존 관계에 대한 문제

* 복구 불가능한 예외
- 대부분의 예외는 복구가 불가능하다. 아주 적은 수만 복구가 가능하다.
- SQLException 은 데이터베이스에서 발생한 문제 때문에 발생하는 예외이다.
  SQL 문법이 잘못된 문제, 데이터베이스 자체에 발생한 문제(다운 등) 등 대부분 복구가 불가능한 문제이다.
  특히나 대부분의 서비스나 컨트롤러는 이런 문제를 해결할 수 없다.
  따라서 이런 문제들은 일관성 있게 공통으로 처리해야 한다. 오류 로그를 남기고 개발자가 해당 오류를 빠르게 인지할 수 있어야 한다.
  서블릿 필터, 스프링 인터셉터, 스프링 ControllerAdvice 등을 사용하면 공통으로 문제 처리가 가능하다.

* 의존 관계에 대한 문제
- 복구 불가능한 예외임에도 체크 예외이기 때문에 컨트롤러나 서비스는 자신이 처리할 수 없어도 어쩔 수 없이 throws 선언문을 가져가야 한다.
- 왜 이것이 문제가 되나? 바로 서비스, 컨트롤러에서 java.sql.SQLException 을 의존하기 때문이다.
- 향후 JDBC 리포지토리 기술을 다른 기술로 변경한다면? 그래서 SQLException 이 아니라 예를들어 JPAException으로 변경해야 한다면 어떻게 될까?
  SQLException에 의존하던 모든 서비스, 컨트롤러의 코드를 고쳐야 한다. (상위 모듈이 하위 모듈을 의존하게 되어버렸다.)
- 결과적으로 OCP, DI를 통해 클라이언트 코드의 변경 없이 대상 구현체를 변경할 수 있다는 장점이 체크 예외에 발목을 잡히게 되었다.

* 정리
- 처리할 수 있는 체크 예외라면 서비스나 컨트롤러에서 처리하겠지만 지금처럼 데이터베이스나 네트워크 통신처럼 시스템 레벨에서 올라온 예외들은
  대부분 복구가 불가능하다. 그리고 실무에서 발생하는 대부분의 예외들은 이런 시스템 예외들이다.
- 문제는 이런 경우에 체크 예외를 사용하면 아래에서 올라온 복구 불가능한 예외를 서비스, 컨트롤러 같은 클래스가 알고 있어야 한다는 것이다.
  그래서 불필요한 의존관계가 형성된다는 문제가 발생한다.

* throws Exception
- 그렇다면 이렇게 불필요한 의존관계를 형성케 하는 예외를 throws Exception 으로 선언하면 어떨까?
- 코드가 깔끔해지고 의존관계를 벗어날 수는 있다.
- 하지만 Exception은 최상위 타입이므로 모든 체크 예외를 커버해 버린다.
  결과적으로 다른 체크 예외 타입은 throws Exception 선언으로 인해 컴파일러와 IDE가 표시해 주지 않는다는 문제가 생긴다.
  의도치않게 중요한 예외를 보지 못하게 될 가능성이 생기는 것이다.
- 이렇게 모든 예외를 다 던지는 것은 체크 예외 의도에 반하는 것이다.
  따라서 꼭 필요한 경우가 아니라면 Exception 자체를 던지도록 하면 안된다. (안티 패턴 중 하나이다.)

그렇다면 대안은...? "언체크 예외"이다.
