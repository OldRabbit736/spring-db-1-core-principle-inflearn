==== 트랜잭션 문제 해결 - 트랜잭션 매니저 1 ====
애플리케이션 코드에 트랜잭션 매니저 적용해 보자.
--> MemberRepositoryV3

* DataSourceUtils.getConnection()
- 트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환한다.
- 없다면 새로운 커넥션을 생성해서 반환한다.

* DataSourceUtils.releaseConnection()
- 커넥션을 바로 닫는 것이 아니다. (트랜잭션이 종료(커밋, 롤백)될 때까지 살아있어야 한다.)
- 트랜잭션 동기화 매니저에 의해 관리되는 커넥션은 닫지 않는다.
- 트랜잭션 동기화 매니저에 의해 관리되는 커넥션이라면 닫는다.

==== 트랜잭션 문제 해결 - 트랜잭션 매니저 2 ====
* 트랜잭션 시작
- 서비스 계층에서 transactionManager.getTransaction()을 호출해서 트랜잭션을 시작한다.
- 트랜잭션 시작을 위해서는 데이터베이스 커넥션이 필요하다. 트랜잭션 매니저는 전달받은 DataSource를 사용해서 커넥션을 생성한다.
- 커넥션을 수동 커밋 모드로 변경해서 실제 데이터베이스 트랜잭션을 시작한다.
- 커넥션을 트랜잭션 동기화 매니저에 보관한다.
- 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. 따라서 멀티 쓰레드 환경에 안전하게 커넥션을 보관할 수 있다.

* 로직 실행
- 서비스는 비즈니스 로직을 실행하면서 리포지토리 메서드들을 호출한다. 이때 커넥션을 파라미터로 전달받지 않는다.
- 리포지토리 메서드들은 트랜잭션이 시작된 커넥션이 필요하다. 리포지토리는 DataSourceUtils.getConnection()을 사용해서
  트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내어 사용한다. 이 과정을 통해 자연스럽게 같은 커넥션을 사용하게 되어 트랜잭션도 유지된다.
- 획득한 커넥션을 사용해서 SQL을 데이터베이스에 전달한다.
- 메서드마다 release를 실행하지만 connection을 실제로 닫는 것은 아니다.
  만약 트랜잭션 동기화 매니저에 의해 관리되는 connection이라면 닫지 않는다.
  트랜잭션 중이므로 커밋이나 롤백 시에만 connection이 닫혀야 하기 때문이다.

* 트랜잭션 종료
- 비즈니스 로직이 끝나고 트랜잭션을 커밋하거나 롤백한다.
- 트랜잭션을 종료하려면 동기화된 커넥션이 필요하다. 트랜잭션 동기화 매니저를 통해 동기화된 커넥션을 획득한다.
- 획득한 커넥션을 통해 데이터베이스에 트랜잭션을 커밋하거나 롤백한다.
- 전체 리소스를 정리한다.
    - 트랜잭션 동기화 매니저를 정리한다. 쓰레드 로컬은 사용 후 꼭 정리해야 한다.
    - con.setAutoCommit(true) 호출하여 오토커밋 모드로 되돌린다. 해당 커넥션은 커넥션 풀로 돌아갈 커넥션이다.
    - con.close()를 호출하여 커넥션을 종료한다. 커넥션 풀에서 가져온 커넥션일 경우 con.close() 호출되면 커넥션 풀에 반환된다.

* 정리
- 트랜잭션 추상화 덕분에 서비스 코드는 JDBC 기술에 더 이상 의존하지 않는다. PlatformTransactionManager 라는 추상화에 의존한다.
    - JDBC에서 JPA로 구현체를 변경해도 서비스 코드는 변경하지 않아도 된다.
    - 기술 변경시 의존관계 주입만 DataSourceTransactionManager에서 JpaTransactionManager로 변경해주면 된다.
    - java.sql.SQLException이 라는 JDBC 기술이 아직 남아있지만 이 부분은 뒤에서 해결 예정이다.
- 트랜잭션 동기화 매니저 덕분에 커넥션을 파라미터로 넘기지 않아도 된다.
    - 트랜잭션 동기화 매니저는 서비스, 리포지터리가 같은 커넥션을 사용할 수 있도록 도와준다.

* 참고
여기서는 DataSourceTransactionManager의 동작 방식을 위주로 설명했다. 다른 트랜잭션 매니저는 동작 방식이 조금씩 다르다.
