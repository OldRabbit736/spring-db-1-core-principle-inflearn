==== 트랜잭션 예제1 - 개념 이해 ====
* 트랜잭션 사용법
- 데이터 변경 쿼리를 실행하고 데이터베이스가 그 결과를 반영하게 하려면 커밋 명령어 "commit"을 호출해야 하고,
  반영하고 싶지 않다면 롤백 명령어 "rollback"을 호출하면 된다.
  (spring을 사용하다보면 commit 명령어를 수행하지 않아도 변경점이 반영되는데, autocommit 모드가 켜져 있기 때문에 그렇다)
- 커밋을 호출하기 전까지는 데이터가 임시로 저장되어 있는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고
  다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.
- 등록, 수정, 삭제 모두 같은 원리로 동작한다. 앞으로 등록, 수정, 삭제를 간단히 "변경" 이라는 단어로 표현하겠다.

* 트랜잭션 및 세션관련 자세한 설명 --> "3. 트랜잭션 이해.pdf"의 "4, 5, 6 페이지 그림 참조"
- 커밋하지 않은 데이터 --> 데이터베이스에 임시로 저장되며 해당 내용은 데이터를 저장한 세션에게만 보이며 다른 세션은 볼 수 없다.
    - 커밋 --> 임시로 저장된 데이터가 정식으로 저장된다. (임시 -> 완료 상태로 변경) 다른 세선도 이제 해당 데이터를 볼 수 있다.
    - 롤백 --> 임시로 저장한 데이터가 삭제되어 트랜잭션 시작하기 전 상태로 복구된다.

* 커밋하지 않은 데이터를 다른 곳에서 조회할 수 있다면 어떤 문제가 발생할까?
- 세션1이 인서트했지만 커밋하지 않은 데이터가 있을 때(회원1, 회원2), 세션2에서 해당 데이터를 조회해서 볼 수 있다고 하자.
- 세션2의 사용자는 해당 데이터를 이용해 어떤 로직을 수행한다.
- 그런데 세션1의 사용자가 롤백을 수행하면 회원1, 회원2에 대한 데이터가 DB에서 사라지게 된다. 즉 "데이터 정합성"에 큰 문제가 발생한다.
- 세션2에서 세션1이 아직 커밋하지 않는 변경 데이터가 보인다면, 세션1이 롤백했을 때 심각한 문제가 발생할 수 있다.
  따라서 커밋 전의 데이터가 다른 세션에서 보이는 것은 위험하다.
- 트랜잭션 격리 수준 중 "READ UNCOMMITTED"가 이런 커밋되지 않는 데이터를 읽는 행위를 허락한다.
- 실질적으로 이 "READ UNCOMMITTED"는 특별한 케이스를 제외하고는 사용되는 일은 없다고 볼 수 있다.

