==== DB 락 - 개념 이해 ====
세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데
세션2에서 동시에 같은 데이터를 수정하면 여러가지 문제가 발생한다.
바로 트랜잭션의 원자성 원자성이 깨지는 것이다. (어떤 데이터로 롤백을 해야 하지?)
세션1이 중간에 롤백을 하게되면 세션2는 잘못된 데이터를 수정하는 문제가 발생한다.

다른 말로는, 어떤 row가 수정되려면 해당 row가 진정된 상태(변경 완료된 상태)일 필요가 있다는 것이다.
lock은 row의 불안정한 상태(변경 중)를 의미한다고도 볼 수 있다.

이런 문제를 방지하려면, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 (커밋이나 롤백 전에는)
다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.

* 락 - 변경
- 세션1과 2가 트랜잭션을 시작하고 member1에 대한 변경을 시도한다.
- 세션1가 2보다 약간 빨라서 해당 로우의 락을 획득한다.
- 세션1은 락을 획득했으므로 해당 로우에 update SQL을 수행한다.
- 세션2도 락을 얻으려 하였지만 락이 없으므로 락이 돌아올 때까지 대기한다.
- 세션1은 commit이나 rollback을 수행하고 락을 반환한다.
- 세션2는 락을 얻어 SQL을 수행한다.
- 세션2은 commit이나 rollback을 수행하고 락을 반환한다.

- 참고로 세션2가 락을 무한정 기다리지 않는다. 락 대기 타임아웃이 있고 넘어서면 오류가 발생한다. 락 대기 타임아웃은 설정할 수 있다.

* 일반적인 조회
- 데이터베이스마다 다르지만, 보통 락을 획득하지 않아도 데이터를 조회할 수 있게 되어 있다. (물론 변경되고 있는 데이터가 아니라 그 이전 버전의 데이터)

* 조회와 락
- 읽기 시점에 락을 걸어버릴 수 있다. "select for update" 구문을 사용하면 된다.
(예: select * from member where member_id='memberA' for update;)
- 이렇게 하면 세션1이 조회 시점에 락을 습득하기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다.
- 트랜잭션 커밋이나 롤백 시 락을 반납한다. 여기서 커밋을 한다고 해도 해당 row에 변경되는 점은 없다.
  단지 lock 반납을 위한 커밋일 뿐이다.

* 읽기 시점에 락을 걸어야 하는 유즈케이스?
- 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다.
- 예를들어, 애플리케이션 로직에서 memberA의 금액을 조회하여 이 금액 정보로 애플리케이션에서 어떤 계산을 수행한다.
- 이 계산이 돈과 계산된 매우 중요한 계산이어서 계산을 완료할 때까지 memberA의 금액을 다른 곳에서 변경하면 안된다.
- 이런 경우 조회 시점에 락을 걸어주면 된다.

* 중요
- 트랜잭션과 락은 데이터베이스마다 동작이 조금씩 다르기 때문에, 해당 데이터베이스 매뉴얼을 확인하고 테스트 후 사용해야 한다.

==== 요약 ====
세션1이 트랜잭션을 시작하고 다음의 동작을 수행 중이라고 하자.
인서트 --> 새로운 row가 생기고 lock이 걸려 있는 상태
수정(업데이트, 지우기) --> 존재하던 row에 임시 변경이 적용되고 lock이 걸려 있는 상태

이 상황에서, 다른 세션이
- 읽기를 수행하면 --> 해당 row의 "이전 버전"을 읽는다.
    - "새로운 row"의 이전 버전은 빈 row(없음)이다.
    - "수정 중인 row"의 이전 버전은 임시 변경점 적용 전의 row이다.
- 수정을 수행하면 --> 해당 row에 대한 수정을 수행할 수 없다. (왜냐하면 lock이 걸려 있으니까)

즉 다른 말로,
lock 걸려있는 row를 읽을 땐 "이전 버전"을 읽고
lock 걸려있는 row를 수정할 수 없다.

또는 다른 말로,
세션1이 수정 중인 row(인서트, 업데이트, 삭제)에 대해서,
세션2는 읽기를 제외한 수정을 할 수 없다.(세션1이 아직 row의 lock을 돌려놓지 않았다.)
읽을 때는 "이전 버전"의 기록을 읽을 수있다.
- 인서트 중인 row --> 기록 없음
- 업데이트 중인 row --> 업데이트 전 row
- 삭제 중인 row --> 존재하던 row
세션1이 commit을 해야 변경이 인정되어 다른 세션에서도 변경된 데이터를 읽을 수 있으며
되돌려진 lock을 얻으면 수정도 할 수 있다.

즉 row는 2가지 상태 -- locked, not locked -- 를 가질 수 있으며
상태에 따라 세션의 읽기, 수정 행위가 달라진다.

==== 요약 2 ====
보통 읽기를 시도할 때 락을 걸지는 않는다.
하지만 필요에 의해 락을 거는 것도 가능하다.
